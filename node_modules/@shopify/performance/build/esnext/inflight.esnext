import { now } from './utilities.esnext';
import { EventType, NavigationResult } from './types.esnext';
import { Navigation } from './navigation.esnext';

function replaceResourceEvent(event, oldEvent) {
  if (event.type !== EventType.ScriptDownload && event.type !== EventType.StyleDownload || oldEvent.type !== EventType.ScriptDownload && oldEvent.type !== EventType.StyleDownload) {
    return false;
  }

  return event.type === oldEvent.type && event.metadata.name === oldEvent.metadata.name;
}

const MATCHES_CHECK_MAP = new Map([// In Safari, we occasionally get the same "resource" event twice.
// This check looks for a resource event with the same name, and replaces
// it if found.
[EventType.ScriptDownload, replaceResourceEvent], [EventType.StyleDownload, replaceResourceEvent]]);

function defaultEqualityCheck({
  type
}, {
  type: otherType
}) {
  return type === otherType;
}

class InflightNavigation {
  constructor({
    timeOrigin,
    start = now(),
    target = window.location.pathname
  }, metadata) {
    this.metadata = metadata;
    this.timeOrigin = void 0;
    this.start = void 0;
    this.target = void 0;
    this.events = [];
    this.timeOrigin = timeOrigin;
    this.start = this.normalize(start);
    this.target = target;
  }

  event(event, // Users can either force "matching" events to be replaced, or provide
  // a function that checks for an event that should be replaced. This may
  // be necessary if events can be triggered multiple times because of
  // browser inconsistencies.
  replaceExisting = false) {
    const normalizedEvent = { ...event,
      start: this.normalize(event.start)
    };

    if (replaceExisting) {
      const check = typeof replaceExisting === 'function' ? replaceExisting : MATCHES_CHECK_MAP.get(event.type) || defaultEqualityCheck;
      const existingIndex = this.events.findIndex(oldEvent => check(event, oldEvent));

      if (existingIndex >= 0) {
        this.events.splice(existingIndex, 1, normalizedEvent);
      } else {
        this.events.push(normalizedEvent);
      }
    } else {
      this.events.push(normalizedEvent);
    }
  }

  cancel(timeStamp = now()) {
    return this.end(timeStamp, NavigationResult.Cancelled);
  }

  timeout(timeStamp = now()) {
    return this.end(timeStamp, NavigationResult.TimedOut);
  }

  finish(timeStamp = now()) {
    return this.end(timeStamp, NavigationResult.Finished);
  }

  end(timeStamp, result) {
    return new Navigation({
      target: this.target,
      start: this.start,
      duration: this.normalize(timeStamp) - this.start,
      events: this.events.sort((eventOne, eventTwo) => eventOne.start - eventTwo.start),
      result
    }, this.metadata);
  }

  normalize(timeStamp) {
    return this.timeOrigin + timeStamp;
  }

}

export { InflightNavigation };
