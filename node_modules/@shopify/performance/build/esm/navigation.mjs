import { EventType } from './types.mjs';
import { getUniqueRanges } from './utilities.mjs';

const LIFECYCLE_EVENTS = [EventType.TimeToFirstByte, EventType.TimeToFirstPaint, EventType.TimeToFirstContentfulPaint, EventType.DomContentLoaded, EventType.FirstInputDelay, EventType.Load];
class Navigation {
  get isFullPageNavigation() {
    return this.metadata.index === 0;
  }

  constructor({
    start,
    duration,
    target,
    events,
    result
  }, metadata) {
    this.metadata = metadata;
    this.start = void 0;
    this.duration = void 0;
    this.target = void 0;
    this.events = void 0;
    this.result = void 0;
    this.start = start;
    this.duration = duration;
    this.target = target;
    this.events = events;
    this.result = result;
  }

  eventsByType(targetType) {
    return this.events.filter(({
      type
    }) => type === targetType);
  }

  totalDurationByEventType(type, {
    countOverlaps = false
  } = {}) {
    const events = this.eventsByType(type);
    const {
      start: navigationStart
    } = this;

    if (events.length === 0) {
      return 0;
    }

    const ranges = countOverlaps ? events : getUniqueRanges(events);
    return ranges.reduce((total, {
      start,
      duration
    }) => total + duration - Math.max(0, navigationStart - start), 0);
  }

  get timeToComplete() {
    return this.duration;
  }

  get timeToUsable() {
    const usableEvent = this.eventsByType(EventType.Usable)[0];
    return usableEvent ? usableEvent.start - this.start : this.timeToComplete;
  }

  get resourceEvents() {
    return [...this.eventsByType(EventType.ScriptDownload), ...this.eventsByType(EventType.StyleDownload)];
  }

  get totalDownloadSize() {
    const events = this.resourceEvents;

    if (events.length === 0) {
      return undefined;
    }

    return events.reduce((total, {
      metadata: {
        size
      }
    }) => size == null || typeof total !== 'number' ? undefined : total + size, 0);
  }

  get cacheEffectiveness() {
    const events = this.resourceEvents;

    if (events.length === 0 || events.some(({
      metadata: {
        size
      }
    }) => size == null)) {
      return undefined;
    }

    return events.filter(({
      duration
    }) => duration === 0).length / events.length;
  }

  toJSON({
    removeEventMetadata = true,
    removeLifecycleEvents = true
  } = {}) {
    const events = removeLifecycleEvents ? this.events.filter(({
      type
    }) => !LIFECYCLE_EVENTS.includes(type)) : this.events;
    const processedEvents = removeEventMetadata ? events.map(({
      metadata,
      ...rest
    }) => rest) : events;
    return {
      start: this.start,
      duration: this.duration,
      target: this.target,
      events: processedEvents,
      result: this.result
    };
  }

}

export { Navigation };
