{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatHistogramOrSummary = formatHistogramOrSummary;\nexports.findExistingMetric = findExistingMetric;\nexports.formatCounterOrGauge = formatCounterOrGauge;\n\nvar _lodash = require(\"lodash\");\n\nfunction getLabelPairs(metric) {\n  var pairs = (0, _lodash.map)(metric.labels, function (v, k) {\n    return \"\".concat(k, \"=\\\"\").concat(v, \"\\\"\");\n  });\n  return pairs.length === 0 ? '' : \"\".concat(pairs.join(','));\n}\n\nfunction formatHistogramOrSummary(name, metric) {\n  var bucketLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'le';\n  var str = '';\n  var labels = getLabelPairs(metric);\n\n  if (labels.length > 0) {\n    str += \"\".concat(name, \"_count{\").concat(labels, \"} \").concat(metric.value.count, \"\\n\");\n    str += \"\".concat(name, \"_sum{\").concat(labels, \"} \").concat(metric.value.sum, \"\\n\");\n  } else {\n    str += \"\".concat(name, \"_count \").concat(metric.value.count, \"\\n\");\n    str += \"\".concat(name, \"_sum \").concat(metric.value.sum, \"\\n\");\n  }\n\n  return (0, _lodash.reduce)(metric.value.entries, function (result, count, bucket) {\n    if (labels.length > 0) {\n      str += \"\".concat(name, \"_bucket{\").concat(bucketLabel, \"=\\\"\").concat(bucket, \"\\\",\").concat(labels, \"} \").concat(count, \"\\n\");\n    } else {\n      str += \"\".concat(name, \"_bucket{\").concat(bucketLabel, \"=\\\"\").concat(bucket, \"\\\"} \").concat(count, \"\\n\");\n    }\n\n    return str;\n  }, str);\n}\n\nfunction findExistingMetric(labels) {\n  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []; // If there are no labels, there can only be one metric\n\n  if (!labels) {\n    return values[0];\n  }\n\n  return (0, _lodash.find)(values, function (v) {\n    return (0, _lodash.isEqual)(v.labels, labels);\n  });\n}\n\nfunction formatCounterOrGauge(name, metric) {\n  var value = \" \".concat(metric.value.toString()); // If there are no keys on `metric`, it doesn't have a label;\n  // return the count as a string.\n\n  if (metric.labels == null || Object.keys(metric.labels).length === 0) {\n    return \"\".concat(name).concat(value, \"\\n\");\n  }\n\n  var pair = (0, _lodash.map)(metric.labels, function (v, k) {\n    return \"\".concat(k, \"=\\\"\").concat(v, \"\\\"\");\n  });\n  return \"\".concat(name, \"{\").concat(pair.join(','), \"}\").concat(value, \"\\n\");\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AAGA,SAASA,aAAT,CAAuBC,MAAvB,EAA4D;AAC1D,MAAMC,KAAK,GAAG,iBAAID,MAAM,CAACE,MAAX,EAAmB,UAACC,CAAD,EAAIC,CAAJ;AAAA,qBAAaA,CAAb,gBAAmBD,CAAnB;AAAnB,IAAd;AACA,SAAOF,KAAK,CAACI,MAANJ,KAAiB,CAAjBA,GAAqB,EAArBA,aAA6BA,KAAK,CAACK,IAANL,CAAW,GAAXA,CAA7B,CAAP;AACD;;AAEM,SAASM,wBAAT,CACLC,IADK,EAELR,MAFK,EAIG;AAAA,MADRS,WACQ,uEADM,IACN;AACR,MAAIC,GAAG,GAAG,EAAV;AACA,MAAMR,MAAM,GAAGH,aAAa,CAACC,MAAD,CAA5B;;AACA,MAAIE,MAAM,CAACG,MAAPH,GAAgB,CAApB,EAAuB;AACrBQ,OAAG,cAAOF,IAAP,oBAAqBN,MAArB,eAAgCF,MAAM,CAACW,KAAPX,CAAaY,KAA7C,OAAHF;AACAA,OAAG,cAAOF,IAAP,kBAAmBN,MAAnB,eAA8BF,MAAM,CAACW,KAAPX,CAAaa,GAA3C,OAAHH;AAFF,SAGO;AACLA,OAAG,cAAOF,IAAP,oBAAqBR,MAAM,CAACW,KAAPX,CAAaY,KAAlC,OAAHF;AACAA,OAAG,cAAOF,IAAP,kBAAmBR,MAAM,CAACW,KAAPX,CAAaa,GAAhC,OAAHH;AACD;;AAED,SAAO,oBAAOV,MAAM,CAACW,KAAPX,CAAac,OAApB,EAA6B,UAACC,MAAD,EAASH,KAAT,EAAgBI,MAAhB,EAA2B;AAC7D,QAAId,MAAM,CAACG,MAAPH,GAAgB,CAApB,EAAuB;AACrBQ,SAAG,cAAOF,IAAP,qBAAsBC,WAAtB,gBAAsCO,MAAtC,gBAAiDd,MAAjD,eAA4DU,KAA5D,OAAHF;AADF,WAEO;AACLA,SAAG,cAAOF,IAAP,qBAAsBC,WAAtB,gBAAsCO,MAAtC,iBAAkDJ,KAAlD,OAAHF;AACD;;AAED,WAAOA,GAAP;AAPK,KAQJA,GARI,CAAP;AASD;;AAEM,SAASO,kBAAT,CACLf,MADK,EAGkB;AAAA,MADvBgB,MACuB,uEADD,EACC,EACvB;;AACA,MAAI,CAAChB,MAAL,EAAa;AACX,WAAOgB,MAAM,CAAC,CAAD,CAAb;AACD;;AACD,SAAO,kBAAKA,MAAL,EAAa,aAAC;AAAA,WAAI,qBAAQf,CAAC,CAACD,MAAV,EAAkBA,MAAlB,CAAJ;AAAd,IAAP;AACD;;AAEM,SAASiB,oBAAT,CAA8BX,IAA9B,EAA4CR,MAA5C,EAAiF;AACtF,MAAMW,KAAK,cAAOX,MAAM,CAACW,KAAPX,CAAaoB,QAAbpB,EAAP,CAAX,CADsF,CAEtF;AACA;;AACA,MAAIA,MAAM,CAACE,MAAPF,IAAiB,IAAjBA,IAAyBqB,MAAM,CAACC,IAAPD,CAAYrB,MAAM,CAACE,MAAnBmB,EAA2BhB,MAA3BgB,KAAsC,CAAnE,EAAsE;AACpE,qBAAUb,IAAV,SAAiBG,KAAjB;AACD;;AACD,MAAMY,IAAI,GAAG,iBAAIvB,MAAM,CAACE,MAAX,EAAmB,UAACC,CAAD,EAAIC,CAAJ;AAAA,qBAAaA,CAAb,gBAAmBD,CAAnB;AAAnB,IAAb;AACA,mBAAUK,IAAV,cAAkBe,IAAI,CAACjB,IAALiB,CAAU,GAAVA,CAAlB,cAAoCZ,KAApC;AACD","names":["getLabelPairs","metric","pairs","labels","v","k","length","join","formatHistogramOrSummary","name","bucketLabel","str","value","count","sum","entries","result","bucket","findExistingMetric","values","formatCounterOrGauge","toString","Object","keys","pair"],"sources":["D:\\3.0 SRINIVAS-WORKS\\TEMP\\user-ui\\node_modules\\src\\utils.ts"],"sourcesContent":["import { find, isEqual, map, reduce } from 'lodash';\nimport { HistogramValue, Labels, Metric, MetricValue } from './types';\n\nfunction getLabelPairs(metric: Metric<MetricValue>): string {\n  const pairs = map(metric.labels, (v, k) => `${k}=\"${v}\"`);\n  return pairs.length === 0 ? '' : `${pairs.join(',')}`;\n}\n\nexport function formatHistogramOrSummary(\n  name: string,\n  metric: Metric<HistogramValue>,\n  bucketLabel = 'le',\n): string {\n  let str = '';\n  const labels = getLabelPairs(metric);\n  if (labels.length > 0) {\n    str += `${name}_count{${labels}} ${metric.value.count}\\n`;\n    str += `${name}_sum{${labels}} ${metric.value.sum}\\n`;\n  } else {\n    str += `${name}_count ${metric.value.count}\\n`;\n    str += `${name}_sum ${metric.value.sum}\\n`;\n  }\n\n  return reduce(metric.value.entries, (result, count, bucket) => {\n    if (labels.length > 0) {\n      str += `${name}_bucket{${bucketLabel}=\"${bucket}\",${labels}} ${count}\\n`;\n    } else {\n      str += `${name}_bucket{${bucketLabel}=\"${bucket}\"} ${count}\\n`;\n    }\n\n    return str;\n  }, str);\n}\n\nexport function findExistingMetric<T extends MetricValue>(\n  labels?: Labels,\n  values: Metric<T>[] = [],\n): Metric<T> | undefined {\n  // If there are no labels, there can only be one metric\n  if (!labels) {\n    return values[0];\n  }\n  return find(values, v => isEqual(v.labels, labels));\n}\n\nexport function formatCounterOrGauge(name: string, metric: Metric<MetricValue>): string {\n  const value = ` ${metric.value.toString()}`;\n  // If there are no keys on `metric`, it doesn't have a label;\n  // return the count as a string.\n  if (metric.labels == null || Object.keys(metric.labels).length === 0) {\n    return `${name}${value}\\n`;\n  }\n  const pair = map(metric.labels, (v, k) => `${k}=\"${v}\"`);\n  return `${name}{${pair.join(',')}}${value}\\n`;\n}\n"]},"metadata":{},"sourceType":"script"}