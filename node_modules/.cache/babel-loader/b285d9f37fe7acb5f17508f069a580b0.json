{"ast":null,"code":"function referenceTime() {\n  // If no performance, then we always used Date.now(), which is a full\n  // (if inaccurate) timestamp\n  if (typeof performance === 'undefined') {\n    return 0;\n  } // Safari does not support performance.timeOrigin. We simulate it by using the\n  // (less precise) Date.now(), and subtracting the time since the timeOrigin\n  // (performance.now())\n\n\n  return performance.timeOrigin || Date.now() - performance.now();\n}\n\nfunction now() {\n  return typeof performance === 'undefined' ? Date.now() : performance.now();\n}\n\nfunction withEntriesOfType(type, handler) {\n  try {\n    // Can't use getEntriesByType() without causing deprecation warnings on\n    // Chrome with some types, so we get all and filter it ourselves\n    const initialEntries = performance.getEntries().filter(entry => entry.entryType === type);\n    initialEntries.forEach(entry => handler(entry));\n\n    if (!hasGlobal('PerformanceObserver')) {\n      return;\n    }\n\n    const observer = new PerformanceObserver(entries => {\n      entries.getEntriesByType(type).forEach(entry => handler(entry));\n    });\n    observer.observe({\n      type,\n      buffered: true\n    });\n  } catch (error) {// Browser support here is weird. Some browsers support getting\n    // the initial entries, but don't support performance observers.\n    // Some throw errors when invalid types are passed, others don't.\n    // We're being very protective here, but I think it's the only way.\n  }\n}\n\nfunction withNavigation(handler) {\n  const {\n    pushState,\n    replaceState\n  } = window.history;\n  let currentPathname = window.location.pathname;\n\n  const handlePushOrReplace = url => {\n    const pathname = url ? new URL(url, window.location.href).pathname : undefined;\n\n    if (pathname !== window.location.pathname) {\n      currentPathname = pathname;\n      handler({\n        target: pathname\n      });\n    }\n  };\n\n  window.addEventListener('popstate', () => {\n    if (currentPathname !== window.location.pathname) {\n      currentPathname = window.location.pathname;\n      handler();\n    }\n  });\n\n  history.replaceState = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    handlePushOrReplace(args[2]);\n    replaceState.call(history, ...args);\n  };\n\n  history.pushState = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    handlePushOrReplace(args[2]);\n    pushState.call(history, ...args);\n  };\n}\n\nfunction withTiming(handler) {\n  if (typeof document === 'undefined' || typeof performance === 'undefined') {\n    return;\n  }\n\n  if (document.readyState === 'complete') {\n    handler(performance.timing);\n  } else {\n    window.addEventListener('load', () => handler(performance.timing), {\n      once: true\n    });\n  }\n}\n\nconst supportsPerformanceObserver = typeof PerformanceObserver !== 'undefined';\n\nfunction hasGlobal(global) {\n  return typeof window !== 'undefined' && global in window;\n}\n\nfunction getUniqueRanges(ranges) {\n  const uniqueRanges = new Set();\n  ranges.forEach(range => {\n    const overlappingRanges = [...uniqueRanges].filter(otherRange => rangesOverlap(range, otherRange));\n\n    for (const overlappingRange of overlappingRanges) {\n      uniqueRanges.delete(overlappingRange);\n    }\n\n    uniqueRanges.add(squashRanges([range, ...overlappingRanges]));\n  });\n  return [...uniqueRanges];\n}\n\nfunction rangesOverlap(rangeOne, rangeTwo) {\n  const rangeOneEnd = rangeOne.start + rangeOne.duration;\n  const rangeTwoEnd = rangeTwo.start + rangeTwo.duration;\n  return (// rangeOne starts in rangeTwo\n    rangeOne.start >= rangeTwo.start && rangeOne.start <= rangeTwoEnd || // rangeOne ends in rangeTwo\n    rangeOneEnd >= rangeTwo.start && rangeOneEnd <= rangeTwoEnd || // rangeTwo entirely within rangeOne\n    rangeTwo.start >= rangeOne.start && rangeTwo.start <= rangeOneEnd\n  );\n}\n\nfunction squashRanges(ranges) {\n  const [first, ...rest] = ranges;\n  return rest.reduce((fullRange, range) => {\n    const start = Math.min(range.start, fullRange.start);\n    return {\n      start,\n      duration: Math.max(range.start + range.duration, fullRange.start + fullRange.duration) - start\n    };\n  }, first);\n}\n\nexport { getUniqueRanges, hasGlobal, now, referenceTime, supportsPerformanceObserver, withEntriesOfType, withNavigation, withTiming };","map":{"version":3,"sources":["D:/3.0 SRINIVAS-WORKS/TEMP/user-ui/node_modules/@shopify/performance/build/esm/utilities.mjs"],"names":["referenceTime","performance","timeOrigin","Date","now","withEntriesOfType","type","handler","initialEntries","getEntries","filter","entry","entryType","forEach","hasGlobal","observer","PerformanceObserver","entries","getEntriesByType","observe","buffered","error","withNavigation","pushState","replaceState","window","history","currentPathname","location","pathname","handlePushOrReplace","url","URL","href","undefined","target","addEventListener","args","call","withTiming","document","readyState","timing","once","supportsPerformanceObserver","global","getUniqueRanges","ranges","uniqueRanges","Set","range","overlappingRanges","otherRange","rangesOverlap","overlappingRange","delete","add","squashRanges","rangeOne","rangeTwo","rangeOneEnd","start","duration","rangeTwoEnd","first","rest","reduce","fullRange","Math","min","max"],"mappings":"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","sourcesContent":["function referenceTime() {\n  // If no performance, then we always used Date.now(), which is a full\n  // (if inaccurate) timestamp\n  if (typeof performance === 'undefined') {\n    return 0;\n  } // Safari does not support performance.timeOrigin. We simulate it by using the\n  // (less precise) Date.now(), and subtracting the time since the timeOrigin\n  // (performance.now())\n\n\n  return performance.timeOrigin || Date.now() - performance.now();\n}\nfunction now() {\n  return typeof performance === 'undefined' ? Date.now() : performance.now();\n}\nfunction withEntriesOfType(type, handler) {\n  try {\n    // Can't use getEntriesByType() without causing deprecation warnings on\n    // Chrome with some types, so we get all and filter it ourselves\n    const initialEntries = performance.getEntries().filter(entry => entry.entryType === type);\n    initialEntries.forEach(entry => handler(entry));\n\n    if (!hasGlobal('PerformanceObserver')) {\n      return;\n    }\n\n    const observer = new PerformanceObserver(entries => {\n      entries.getEntriesByType(type).forEach(entry => handler(entry));\n    });\n    observer.observe({\n      type,\n      buffered: true\n    });\n  } catch (error) {// Browser support here is weird. Some browsers support getting\n    // the initial entries, but don't support performance observers.\n    // Some throw errors when invalid types are passed, others don't.\n    // We're being very protective here, but I think it's the only way.\n  }\n}\nfunction withNavigation(handler) {\n  const {\n    pushState,\n    replaceState\n  } = window.history;\n  let currentPathname = window.location.pathname;\n\n  const handlePushOrReplace = url => {\n    const pathname = url ? new URL(url, window.location.href).pathname : undefined;\n\n    if (pathname !== window.location.pathname) {\n      currentPathname = pathname;\n      handler({\n        target: pathname\n      });\n    }\n  };\n\n  window.addEventListener('popstate', () => {\n    if (currentPathname !== window.location.pathname) {\n      currentPathname = window.location.pathname;\n      handler();\n    }\n  });\n\n  history.replaceState = (...args) => {\n    handlePushOrReplace(args[2]);\n    replaceState.call(history, ...args);\n  };\n\n  history.pushState = (...args) => {\n    handlePushOrReplace(args[2]);\n    pushState.call(history, ...args);\n  };\n}\nfunction withTiming(handler) {\n  if (typeof document === 'undefined' || typeof performance === 'undefined') {\n    return;\n  }\n\n  if (document.readyState === 'complete') {\n    handler(performance.timing);\n  } else {\n    window.addEventListener('load', () => handler(performance.timing), {\n      once: true\n    });\n  }\n}\nconst supportsPerformanceObserver = typeof PerformanceObserver !== 'undefined';\nfunction hasGlobal(global) {\n  return typeof window !== 'undefined' && global in window;\n}\nfunction getUniqueRanges(ranges) {\n  const uniqueRanges = new Set();\n  ranges.forEach(range => {\n    const overlappingRanges = [...uniqueRanges].filter(otherRange => rangesOverlap(range, otherRange));\n\n    for (const overlappingRange of overlappingRanges) {\n      uniqueRanges.delete(overlappingRange);\n    }\n\n    uniqueRanges.add(squashRanges([range, ...overlappingRanges]));\n  });\n  return [...uniqueRanges];\n}\n\nfunction rangesOverlap(rangeOne, rangeTwo) {\n  const rangeOneEnd = rangeOne.start + rangeOne.duration;\n  const rangeTwoEnd = rangeTwo.start + rangeTwo.duration;\n  return (// rangeOne starts in rangeTwo\n    rangeOne.start >= rangeTwo.start && rangeOne.start <= rangeTwoEnd || // rangeOne ends in rangeTwo\n    rangeOneEnd >= rangeTwo.start && rangeOneEnd <= rangeTwoEnd || // rangeTwo entirely within rangeOne\n    rangeTwo.start >= rangeOne.start && rangeTwo.start <= rangeOneEnd\n  );\n}\n\nfunction squashRanges(ranges) {\n  const [first, ...rest] = ranges;\n  return rest.reduce((fullRange, range) => {\n    const start = Math.min(range.start, fullRange.start);\n    return {\n      start,\n      duration: Math.max(range.start + range.duration, fullRange.start + fullRange.duration) - start\n    };\n  }, first);\n}\n\nexport { getUniqueRanges, hasGlobal, now, referenceTime, supportsPerformanceObserver, withEntriesOfType, withNavigation, withTiming };\n"]},"metadata":{},"sourceType":"module"}