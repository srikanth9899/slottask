{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _counter = require(\"./counter\");\n\nvar _gauge = require(\"./gauge\");\n\nvar _histogram = require(\"./histogram\");\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Registry = /*#__PURE__*/function () {\n  function Registry() {\n    _classCallCheck(this, Registry);\n\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = {\n      counter: {},\n      gauge: {},\n      histogram: {}\n    };\n  }\n\n  _createClass(Registry, [{\n    key: \"validateInput\",\n    value: function validateInput(type, name, help, buckets) {\n      // checks for js runtime\n      if (String(name) === '') {\n        throw new Error('Metric name cannot be empty');\n      }\n\n      if (['counter', 'gauge', 'histogram'].indexOf(type) === -1) {\n        throw new Error(\"Unknown metric type \".concat(type));\n      }\n\n      if (typeof help !== 'string' && help != null) {\n        throw new Error('help must be string or undefined/null');\n      }\n\n      if ((0, _lodash.has)(this.data, \"\".concat(type, \".\").concat(name))) {\n        throw new Error(\"A metric with the name '\".concat(name, \"' already exists for type '\").concat(type, \"'\"));\n      }\n\n      if (!Array.isArray(buckets) && buckets != null) {\n        throw new Error('buckets must be array or undefined/null');\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(type, name) {\n      var help = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var histogramBuckets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      this.validateInput(type, name, help, histogramBuckets);\n      var instance;\n\n      if (type === 'counter') {\n        instance = new _counter.Counter();\n        this.data.counter[name] = {\n          help: help,\n          instance: instance,\n          type: type\n        };\n      } else if (type === 'gauge') {\n        instance = new _gauge.Gauge();\n        this.data.gauge[name] = {\n          help: help,\n          instance: instance,\n          type: type\n        };\n      } else {\n        instance = new _histogram.Histogram(histogramBuckets);\n        this.data.histogram[name] = {\n          help: help,\n          instance: instance,\n          type: type\n        };\n      }\n\n      return instance;\n    }\n    /**\n     * Returns a string in the prometheus' desired format\n     * More info: https://prometheus.io/docs/concepts/data_model/\n     * Loop through each metric type (counter, histogram, etc);\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"metrics\",\n    value: function metrics() {\n      return (0, _lodash.reduce)(this.data, function (output, metrics, type) {\n        return output + (0, _lodash.reduce)(metrics, function (src, metric, name) {\n          var values = metric.instance.collect();\n          var result = src;\n\n          if (metric.help.length > 0) {\n            result += \"# HELP \".concat(name, \" \").concat(metric.help, \"\\n\");\n          }\n\n          result += \"# TYPE \".concat(name, \" \").concat(type, \"\\n\"); // Each metric can have many labels. Iterate over each and append to the string.\n\n          result += (0, _lodash.reduce)(values, function (str, value) {\n            var formatted = type === 'histogram' ? (0, _utils.formatHistogramOrSummary)(name, value) : (0, _utils.formatCounterOrGauge)(name, value);\n            return str + formatted;\n          }, '');\n          return result;\n        }, '');\n      }, '');\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      (0, _lodash.each)(this.data, function (metrics) {\n        (0, _lodash.each)(metrics, function (_ref) {\n          var instance = _ref.instance;\n          instance.resetAll();\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = {\n        counter: {},\n        gauge: {},\n        histogram: {}\n      };\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get(type, name) {\n      var registryItems = type != null ? [this.data[type]] : (0, _lodash.valuesIn)(this.data);\n      var metric = registryItems.find(function (v) {\n        return (0, _lodash.has)(v, name);\n      });\n      return metric != null ? metric[name].instance : undefined;\n    }\n  }]);\n\n  return Registry;\n}();\n\nexports.Registry = Registry;","map":{"version":3,"mappings":"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","names":["Registry","_classCallCheck","_defineProperty","data","counter","gauge","histogram","type","name","help","buckets","String","Error","indexOf","Array","isArray","histogramBuckets","validateInput","instance","Counter","Gauge","Histogram","output","metrics","src","metric","values","collect","result","length","str","value","formatted","resetAll","registryItems","find","v","undefined"],"sources":["D:\\3.0 SRINIVAS-WORKS\\TEMP\\user-ui\\node_modules\\src\\registry.ts"],"sourcesContent":["import { each, has, reduce, valuesIn } from 'lodash';\nimport { Collector } from './collector';\nimport { Counter } from './counter';\nimport { Gauge } from './gauge';\nimport { Histogram } from './histogram';\nimport { CollectorType, CounterValue, HistogramValue, Metric } from './types';\n\nimport { formatCounterOrGauge, formatHistogramOrSummary } from './utils';\n\ntype CollectorForType<T extends CollectorType> =\n  T extends 'histogram' ? Histogram :\n    T extends 'gauge' ? Gauge :\n      T extends 'counter' ? Counter :\n        never;\n\ninterface RegistryItem<T extends CollectorType> {\n  [key: string]: {\n    type: T;\n    help: string;\n    instance: CollectorForType<T>;\n  };\n}\n\nexport class Registry {\n  private data: {\n    [K in CollectorType]: RegistryItem<K>\n  };\n\n  constructor() {\n    this.data = {\n      counter: {},\n      gauge: {},\n      histogram: {}\n    };\n  }\n\n  private validateInput(\n    type: CollectorType,\n    name: string,\n    help?: string,\n    buckets?: number[],\n  ): void {\n    // checks for js runtime\n    if (String(name) === '') {\n      throw new Error('Metric name cannot be empty');\n    }\n    if (['counter', 'gauge', 'histogram'].indexOf(type) === -1) {\n      throw new Error(`Unknown metric type ${type}`);\n    }\n\n    if (typeof help !== 'string' && help != null) {\n      throw new Error('help must be string or undefined/null');\n    }\n\n    if (has(this.data, `${type}.${name}`)) {\n      throw new Error(`A metric with the name '${name}' already exists for type '${type}'`);\n    }\n\n    if (!Array.isArray(buckets) && buckets != null) {\n      throw new Error('buckets must be array or undefined/null');\n    }\n  }\n\n  create(type: 'counter', name: string, help?: string): Counter;\n\n  create(type: 'gauge', name: string, help?: string): Gauge;\n\n  create(type: 'histogram', name: string, help?: string, histogramBuckets?: number[]): Histogram;\n\n  create(\n    type: CollectorType,\n    name: string,\n    help: string = '',\n    histogramBuckets: number[] = [],\n  ): Collector<any> {\n    this.validateInput(type, name, help, histogramBuckets);\n\n    let instance;\n    if (type === 'counter') {\n      instance = new Counter();\n      this.data.counter[name] = { help, instance, type };\n    } else if (type === 'gauge') {\n      instance = new Gauge();\n      this.data.gauge[name] = { help, instance, type };\n    } else {\n      instance = new Histogram(histogramBuckets);\n      this.data.histogram[name] = { help, instance, type };\n    }\n\n    return instance;\n  }\n\n  /**\n   * Returns a string in the prometheus' desired format\n   * More info: https://prometheus.io/docs/concepts/data_model/\n   * Loop through each metric type (counter, histogram, etc);\n   *\n   * @return {string}\n   */\n  metrics(): string {\n    return reduce(this.data,\n      (output, metrics, type) => output + reduce(metrics, (src, metric, name) => {\n        const values = metric.instance.collect();\n        let result = src;\n        if (metric.help.length > 0) {\n          result += `# HELP ${name} ${metric.help}\\n`;\n        }\n        result += `# TYPE ${name} ${type}\\n`;\n        // Each metric can have many labels. Iterate over each and append to the string.\n        result += reduce(values, (str, value) => {\n          const formatted = type === 'histogram'\n            ? formatHistogramOrSummary(name, value as Metric<HistogramValue>)\n            : formatCounterOrGauge(name, value as Metric<CounterValue>);\n          return str + formatted;\n        }, '');\n        return result;\n      }, ''),\n      '');\n  }\n\n  reset(): this {\n    each(this.data, (metrics) => {\n      each(metrics, ({ instance }) => {\n        instance.resetAll();\n      });\n    });\n    return this;\n  }\n\n  clear(): this {\n    this.data = {\n      counter: {},\n      gauge: {},\n      histogram: {},\n    };\n\n    return this;\n  }\n\n  get(type: 'counter', name: string): Counter | undefined;\n\n  get(type: 'gauge', name: string): Gauge | undefined;\n\n  get(type: 'histogram', name: string): Histogram | undefined;\n\n  get(type: CollectorType, name: string): Collector<any> | undefined {\n    const registryItems = type != null ? [this.data[type]] : valuesIn(this.data);\n    const metric = registryItems.find(v => has(v, name));\n\n    return metric != null ? metric[name].instance : undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}