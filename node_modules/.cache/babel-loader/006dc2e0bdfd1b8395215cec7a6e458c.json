{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Histogram = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _collector = require(\"./collector\");\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction findMinBucketIndex(ary, num) {\n  if (num < ary[ary.length - 1]) {\n    for (var i = 0; i < ary.length; i += 1) {\n      if (num <= ary[i]) {\n        return i;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getInitialValue(buckets) {\n  // Make the skeleton to which values will be saved.\n  var entries = (0, _lodash.reduce)(buckets, function (result, b) {\n    result[b.toString()] = 0;\n    return result;\n  }, {\n    '+Inf': 0\n  });\n  return {\n    entries: entries,\n    sum: 0,\n    count: 0,\n    raw: []\n  };\n}\n\nvar Histogram = /*#__PURE__*/function (_Collector) {\n  _inherits(Histogram, _Collector);\n\n  function Histogram() {\n    var _this;\n\n    var buckets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Histogram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Histogram).call(this)); // Sort to get smallest -> largest in order.\n\n    _defineProperty(_assertThisInitialized(_this), \"buckets\", void 0);\n\n    _this.buckets = buckets.sort(function (a, b) {\n      return a > b ? 1 : -1;\n    });\n\n    _this.set(getInitialValue(_this.buckets));\n\n    _this.observe = _this.observe.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Histogram, [{\n    key: \"observe\",\n    value: function observe(value, labels) {\n      var metric = this.get(labels);\n\n      if (metric == null) {\n        // Create a metric for the labels.\n        metric = this.set(getInitialValue(this.buckets), labels).get(labels);\n      }\n\n      metric.value.raw.push(value);\n      metric.value.entries['+Inf'] += 1;\n      var minBucketIndex = findMinBucketIndex(this.buckets, value);\n\n      if (minBucketIndex != null) {\n        for (var i = minBucketIndex; i < this.buckets.length; i += 1) {\n          var val = metric.value.entries[this.buckets[i].toString()];\n          metric.value.entries[this.buckets[i].toString()] = val + 1;\n        }\n      }\n\n      metric.value.sum = (0, _lodash.sum)(metric.value.raw);\n      metric.value.count += 1;\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(labels) {\n      this.set(getInitialValue(this.buckets), labels);\n    }\n  }]);\n\n  return Histogram;\n}(_collector.Collector);\n\nexports.Histogram = Histogram;","map":{"version":3,"mappings":"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","names":["findMinBucketIndex","ary","num","length","i","undefined","getInitialValue","buckets","entries","result","b","toString","sum","count","raw","Histogram","_classCallCheck","_this","_defineProperty","sort","a","set","observe","bind","value","labels","metric","get","push","minBucketIndex","val","Collector"],"sources":["D:\\3.0 SRINIVAS-WORKS\\TEMP\\user-ui\\node_modules\\src\\histogram.ts"],"sourcesContent":["import { reduce, sum } from 'lodash';\n\nimport { Collector } from './collector';\nimport { HistogramValue, HistogramValueEntries, Labels } from './types';\n\nfunction findMinBucketIndex(ary: number[], num: number): number | undefined {\n  if (num < ary[ary.length - 1]) {\n    for (let i = 0; i < ary.length; i += 1) {\n      if (num <= ary[i]) {\n        return i;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getInitialValue(buckets: number[]): HistogramValue {\n  // Make the skeleton to which values will be saved.\n  const entries = reduce(buckets, (result, b) => {\n    result[b.toString()] = 0;\n    return result;\n  }, { '+Inf': 0 } as HistogramValueEntries);\n\n  return {\n    entries,\n    sum: 0,\n    count: 0,\n    raw: [],\n  };\n}\n\nexport class Histogram extends Collector<HistogramValue> {\n  private readonly buckets: number[];\n\n  constructor(buckets: number[] = []) {\n    super();\n    // Sort to get smallest -> largest in order.\n    this.buckets = buckets.sort((a, b) => (a > b ? 1 : -1));\n    this.set(getInitialValue(this.buckets));\n    this.observe = this.observe.bind(this);\n  }\n\n  observe(value: number, labels?: Labels): this {\n    let metric = this.get(labels);\n    if (metric == null) {\n      // Create a metric for the labels.\n      metric = this.set(getInitialValue(this.buckets), labels).get(labels)!;\n    }\n\n    metric.value.raw.push(value);\n    metric.value.entries['+Inf'] += 1;\n\n    const minBucketIndex = findMinBucketIndex(this.buckets, value);\n\n    if (minBucketIndex != null) {\n      for (let i = minBucketIndex; i < this.buckets.length; i += 1) {\n        const val = metric.value.entries[this.buckets[i].toString()];\n        metric.value.entries[this.buckets[i].toString()] = val + 1;\n      }\n    }\n\n    metric.value.sum = sum(metric.value.raw);\n    metric.value.count += 1;\n\n    return this;\n  }\n\n  reset(labels?: Labels): void {\n    this.set(getInitialValue(this.buckets), labels);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}